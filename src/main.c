#include <stdio.h>
#include <string.h>
#include <stdint.h>
#include <stdbool.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "driver/i2c.h"
#include "esp_log.h"
#include "u8g2.h"

#define TAG "Meteostation"

#define I2C_PORT    I2C_NUM_0
#define I2C_SDA_PIN 21
#define I2C_SCL_PIN 22
#define I2C_FREQ    CONFIG_I2C_MASTER_FREQUENCY
#define DISPLAY_ADDR CONFIG_I2C_DISPLAY_ADDRESS

#define SHT31_ADDR 0x44     //< SHT31 I2C address

static uint8_t i2c_buffer[256];

uint8_t u8g2_esp32_i2c_byte_cb(u8x8_t *u8x8, uint8_t msg, uint8_t arg_int, void *arg_ptr) {
    static size_t index = 0;
    switch(msg) {
        case U8X8_MSG_BYTE_INIT: index = 0; break;
        case U8X8_MSG_BYTE_START_TRANSFER: index = 0; break;
        case U8X8_MSG_BYTE_SEND:
            if (arg_int > 0 && (index + arg_int) < sizeof(i2c_buffer)) {
                memcpy(&i2c_buffer[index], arg_ptr, arg_int);
                index += arg_int;
            }
            break;
        case U8X8_MSG_BYTE_END_TRANSFER:
            if (index > 0) {
                i2c_cmd_handle_t cmd = i2c_cmd_link_create();
                i2c_master_start(cmd);
                i2c_master_write_byte(cmd, (DISPLAY_ADDR << 1) | I2C_MASTER_WRITE, true);
                i2c_master_write(cmd, i2c_buffer, index, true);
                i2c_master_stop(cmd);
                i2c_master_cmd_begin(I2C_PORT, cmd, pdMS_TO_TICKS(1000));
                i2c_cmd_link_delete(cmd);
            }
            break;
        default: return 0;
    }
    return 1;
}

// ------- SHT31 helpers -------
static esp_err_t i2c_write_bytes(uint8_t addr, const uint8_t *bytes, size_t len) {
    i2c_cmd_handle_t cmd = i2c_cmd_link_create();
    i2c_master_start(cmd);
    i2c_master_write_byte(cmd, (addr << 1) | I2C_MASTER_WRITE, true);
    if (len)
        i2c_master_write(cmd, (uint8_t*)bytes, len, true);
    i2c_master_stop(cmd);
    esp_err_t res = i2c_master_cmd_begin(I2C_PORT, cmd, pdMS_TO_TICKS(1000));
    i2c_cmd_link_delete(cmd);
    return res;
}

static esp_err_t i2c_read_bytes(uint8_t addr, uint8_t *data, size_t len) {
    i2c_cmd_handle_t cmd = i2c_cmd_link_create();
    i2c_master_start(cmd);
    i2c_master_write_byte(cmd, (addr << 1) | I2C_MASTER_READ, true);
    if (len > 1) {
        i2c_master_read(cmd, data, len - 1, I2C_MASTER_ACK);
    }
    i2c_master_read_byte(cmd, &data[len - 1], I2C_MASTER_NACK);
    i2c_master_stop(cmd);
    esp_err_t res = i2c_master_cmd_begin(I2C_PORT, cmd, pdMS_TO_TICKS(1000));
    i2c_cmd_link_delete(cmd);
    return res;
}

static void sht31_read(float *temp_c, float *rh) {
    // Single shot high repeatability (0x2400), wait 30ms, read 6 bytes
    const uint8_t cmd[2] = { 0x24, 0x00 };
    i2c_write_bytes(SHT31_ADDR, cmd, 2);
    vTaskDelay(pdMS_TO_TICKS(30));
    
    uint8_t raw[6];
    i2c_read_bytes(SHT31_ADDR, raw, 6);
    
    uint16_t st = ((uint16_t)raw[0] << 8) | raw[1];
    uint16_t srh = ((uint16_t)raw[3] << 8) | raw[4];
    *temp_c = -45.0f + 175.0f * ((float)st / 65535.0f);
    *rh = 100.0f * ((float)srh / 65535.0f);
}

uint8_t u8g2_esp32_gpio_delay_cb(u8x8_t *u8x8, uint8_t msg, uint8_t arg_int, void *arg_ptr) {
    switch(msg) {
        case U8X8_MSG_DELAY_MILLI: vTaskDelay(pdMS_TO_TICKS(arg_int)); break;
        case U8X8_MSG_DELAY_10MICRO: vTaskDelay(1); break;
        default: return 1;
    }
    return 1;
}

void display_progress_bar(u8g2_t *u8g2) {
    /* Progress bar frame */
    u8g2_DrawFrame(u8g2, 10, 60, 108, 4);

    for (int progress = 0; progress <= 100; progress += 5) {
        /* Progress bar fill */
        int fill_width = (progress * 106) / 100;
        u8g2_DrawBox(u8g2, 11, 61, fill_width, 2);

        u8g2_SendBuffer(u8g2);
        vTaskDelay(pdMS_TO_TICKS(75));
    }
}

void app_main(void) {
    ESP_LOGI(TAG, "Starting I2C display + SHT31");
    
    // Configure I2C
    i2c_config_t i2c_config = {
        .mode = I2C_MODE_MASTER,
        .sda_io_num = I2C_SDA_PIN,
        .scl_io_num = I2C_SCL_PIN,
        .sda_pullup_en = GPIO_PULLUP_ENABLE,
        .scl_pullup_en = GPIO_PULLUP_ENABLE,
        .master.clk_speed = I2C_FREQ,
    };
    i2c_param_config(I2C_PORT, &i2c_config);
    i2c_driver_install(I2C_PORT, I2C_MODE_MASTER, 0, 0, 0);
    
    // Initialize OLED
    u8g2_t u8g2;
    u8g2_Setup_ssd1306_i2c_128x64_noname_f(&u8g2, U8G2_R0, u8g2_esp32_i2c_byte_cb, u8g2_esp32_gpio_delay_cb);
    u8x8_SetI2CAddress(&u8g2.u8x8, DISPLAY_ADDR << 1);
    u8g2_InitDisplay(&u8g2);
    u8g2_SetPowerSave(&u8g2, 0);

    while (1) {
        // Read SHT31
        float temp, hum;
        sht31_read(&temp, &hum);

        // Display temperature
        u8g2_ClearBuffer(&u8g2);
        u8g2_SetFont(&u8g2, u8g2_font_ncenB14_tr);

        char line[16];
        snprintf(line, sizeof(line), "%.1f  C", temp);
        u8g2_DrawStr(&u8g2, 15, 38, line);

        // Circle serving as degree symbol
        u8g2_DrawCircle(&u8g2, 59, 25, 2, U8G2_DRAW_ALL);

        // Icon of a thermometer
        // Generated from free icon at https://javl.github.io/image2cpp/
        const uint8_t thermo_bitmap[] = {
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x01, 
            0x00, 0x00, 0x00, 0x00, 0x18, 0x03, 0x00, 0x00, 0x00, 0x00, 0x58, 0x3a, 0x00, 0x00, 0x00, 0x00, 
            0x58, 0x7a, 0x00, 0x00, 0x00, 0x00, 0x58, 0x02, 0x00, 0x00, 0x00, 0x00, 0x58, 0x1a, 0x00, 0x00, 
            0x00, 0x00, 0x58, 0x02, 0x00, 0x00, 0x00, 0x00, 0x58, 0x02, 0x00, 0x00, 0x00, 0x00, 0x58, 0x7a, 
            0x00, 0x00, 0x00, 0x00, 0x58, 0x02, 0x00, 0x00, 0x00, 0x00, 0x58, 0x1e, 0x00, 0x00, 0x00, 0x00, 
            0x58, 0x02, 0x00, 0x00, 0x00, 0x00, 0x58, 0x02, 0x00, 0x00, 0x00, 0x00, 0x58, 0x3a, 0x00, 0x00, 
            0x00, 0x00, 0x58, 0x02, 0x00, 0x00, 0x00, 0x00, 0x58, 0x1a, 0x00, 0x00, 0x00, 0x00, 0x58, 0x02, 
            0x00, 0x00, 0x00, 0x00, 0x58, 0x02, 0x00, 0x00, 0x00, 0x00, 0x58, 0x7a, 0x00, 0x00, 0x00, 0x00, 
            0x48, 0x02, 0x00, 0x00, 0x00, 0x00, 0x4c, 0x06, 0x00, 0x00, 0x00, 0x00, 0xf4, 0x05, 0x00, 0x00, 
            0x00, 0x00, 0xf6, 0x09, 0x00, 0x00, 0x00, 0x00, 0xfa, 0x0b, 0x00, 0x00, 0x00, 0x00, 0xfa, 0x0b, 
            0x00, 0x00, 0x00, 0x00, 0xf4, 0x0d, 0x00, 0x00, 0x00, 0x00, 0x44, 0x04, 0x00, 0x00, 0x00, 0x00, 
            0x18, 0x03, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        };

        // Display bitmap thermometer
        u8g2_DrawXBM(&u8g2, 80, 8, 48, 48, thermo_bitmap);
        u8g2_SendBuffer(&u8g2);

        // Wait 3 seconds with progress bar
        display_progress_bar(&u8g2);

        // vTaskDelay(pdMS_TO_TICKS(3000));
        u8g2_ClearBuffer(&u8g2);


        // Display humidity
        snprintf(line, sizeof(line), "%.1f %%", hum);
        u8g2_DrawStr(&u8g2, 15, 38, line);

        // u8g2_SendBuffer(&u8g2);

        // Icon of a humidity
        // Generated from free icon at https://javl.github.io/image2cpp/
        const uint8_t humidity_bitmap[] = {
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x03, 0x00, 0x00, 
            0x00, 0x00, 0x40, 0x02, 0x00, 0x00, 0x00, 0x00, 0x20, 0x04, 0x00, 0x00, 0x00, 0x00, 0x10, 0x08, 
            0x00, 0x00, 0x00, 0x00, 0x08, 0x10, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x30, 0x00, 0x00, 0x00, 0x00, 
            0x04, 0x60, 0x00, 0x00, 0x00, 0x00, 0x02, 0x40, 0x00, 0x00, 0x00, 0x00, 0x03, 0x80, 0x00, 0x00, 
            0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x01, 0x00, 0x00, 0xc0, 0x00, 0x00, 
            0x03, 0x00, 0x00, 0x40, 0x00, 0x00, 0x02, 0x00, 0x00, 0x60, 0x00, 0x00, 0x06, 0x00, 0x00, 0x20, 
            0x00, 0x00, 0x04, 0x00, 0x00, 0x20, 0x00, 0x00, 0x04, 0x00, 0x00, 0x10, 0x70, 0x04, 0x08, 0x00, 
            0x00, 0x10, 0x48, 0x04, 0x08, 0x00, 0x00, 0x10, 0x48, 0x02, 0x18, 0x00, 0x00, 0x18, 0x48, 0x02, 
            0x10, 0x00, 0x00, 0x08, 0x70, 0x01, 0x10, 0x00, 0x00, 0x08, 0x00, 0x1d, 0x10, 0x00, 0x00, 0x08, 
            0x80, 0x14, 0x10, 0x00, 0x00, 0x08, 0x80, 0x22, 0x10, 0x00, 0x00, 0x08, 0x40, 0x14, 0x10, 0x00, 
            0x00, 0x08, 0x40, 0x1c, 0x10, 0x00, 0x00, 0x18, 0x00, 0x00, 0x18, 0x00, 0x00, 0x10, 0x00, 0x00, 
            0x08, 0x00, 0x00, 0x30, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x20, 0x00, 0x00, 0x04, 0x00, 0x00, 0x40, 
            0x00, 0x00, 0x02, 0x00, 0x00, 0x80, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 
            0x00, 0x00, 0x1e, 0x78, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        };

        // Display bitmap humidity
        u8g2_DrawXBM(&u8g2, 80, 8, 48, 48, humidity_bitmap);
        u8g2_SendBuffer(&u8g2);

        ESP_LOGI(TAG, "T=%.2fC RH=%.2f%%", temp, hum);

        // Wait 3 seconds with progress bar
        display_progress_bar(&u8g2);
        // vTaskDelay(pdMS_TO_TICKS(3000));
    }
}
